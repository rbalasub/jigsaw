#!/usr/bin/python
import sys
import commands
import tokenize
import getopt
import os.path
import re
import math
import time
import codecs

# For top docs supply, --docs_file --docs_mode --limit --per_page
# modes allowed: filelist, urlist, lines, paintlist
# for paintlist use paint_file generated by tokenizer for docs_file

# --topics: exports topics
# --index: makes an index file
# --wordle: generates word clouds
# --topdocs: exports the top documents for each topic

class TypeModel:
  def __init__(self):
    self.dict = tokenize.Dictionary()


  def ReadModel(self, filename):
    self.topics = []
    self.topic_weights = []
    f = open(filename, 'r')
    for line in f:
      line = line.rstrip("\n")
      stringy = line.split(' ')
      multinomial = [float(x) for x in stringy]
      self.topic_weights.append(multinomial.pop())
      self.topics.append(multinomial)
    f.close()

  def Entropy(self, distr):
    entropy = 0.0
    for p in distr:
      entropy = entropy - p * math.log(p, 2)
    return entropy

  def AvgNodeEntropy(self):
    avg = 0
    print len(self.topics[0])
    for i in range(len(self.topics[0])):
      distr = []
      sum = 0
      for t in range(len(self.topics)):
        sum = sum + self.topics[t][i]
      for t in range(len(self.topics)):
        distr.append(self.topics[t][i] / sum)
      avg = avg + self.Entropy(distr)
    return avg / len(self.topics[0])

  def TopWords(self, t):
    ids = range(len(self.topics[t]))
    ids.sort(key=lambda x: self.topics[t][x], reverse=True)
    if self.dict.pos_flag:
      topwords = [self.dict.id2word[id] + '-' + self.dict.id2pos[id]  for id in ids]
    else:
      topwords = [self.dict.id2word[id] for id in ids]
    return topwords

  def TopWeights(self, t):
    topweights = self.topics[t]
    topweights.sort(reverse=True)
    return topweights

class Model:
  def __init__(self, reportfile, entity_names, dict_prefix, title, target_names, domain_names):
    self.ReadReport(reportfile)
    self.ReadModels()
    if int(self.config["num_real_targets"] and self.config["model_targets"] == "YES") > 0:
      self.ReadCoefficients()
    self.SetEntityNames(entity_names)
    self.SetDomainNames(domain_names)
    self.ReadDicts(dict_prefix)
    self.title = title
    if len(target_names):
      self.SetTargetNames(target_names)
    else:
      self.target_names = []
    self.stopwords = {}

  
  def NodeRoleEntropy(self):
   for attr_num in range(int(self.config["num_entity_types"])):
     sys.stdout.write("AvgNodeRoleEntropy=" + str(self.type_models[attr_num].AvgNodeEntropy()) + "\n")

  def ReadStopWords(self, filename):
    f = codecs.open(filename, encoding='utf-8')
    for word in f:
      word = word.rstrip()
      self.stopwords[word] = 1
    f.close()

  def FilterStopWords(self, list, stopwords):
    return [word for word in list if word not in stopwords]

  def SetEntityNames(self, stringy):
    self.entity_names = stringy.split(',')

  def SetDomainNames(self, stringy):
    self.domain_names = stringy.split(',')
    self.domain_names.append("General")
    print stringy, " is ", len(self.domain_names)

  def SetTargetNames(self, stringy):
    self.target_names = stringy.split(',')

  def ReadReport(self, reportfile):
    f = open(reportfile, 'r')
    self.config = {}
    self.config_key_order = []
    for line in f:
      line = line.rstrip("\r\n")
      components = line.split('=')
      self.config[components[0]] = components[1]
      self.config_key_order.append(components[0])
    f.close()

  def ReadCoefficients(self):
    self.coeffs = []
    for target in range(int(self.config["num_real_targets"])):
      f = open(self.config["output_prefix"]
               + ".run.0.avg.model.coefficients.target."
               + str(target), 'r')
      coeff = []
      for line in f:
        line = line.rstrip("\r\n")
        coeff.append(line)
      self.coeffs.append(coeff)
      
  def ReadModels(self):
   self.type_models = []
   for attr_num in range(int(self.config["num_entity_types"])):
     next_type_model = TypeModel()
     next_type_model.ReadModel(self.config["output_prefix"]
                               + ".run.0.avg.model."
                               + str(attr_num))
     self.type_models.append(next_type_model)

  def ReadDicts(self, prefix):
    ctr = 0
    for entity in self.entity_names:
      self.type_models[ctr].dict.ReadIn(prefix + entity)
#self.type_models[ctr].dict.Dump('testing')
      ctr = ctr + 1

  def Wordle(self, prefix):
    html = open (prefix + '_wordle.html', 'w')
    html.write("<html><body><table>")
    html.write("<head><style>"
               "td { font-family: verdana;\n"
               "     font-size: 13px;\n"
               "     border-style: solida;\n"
               "     border-color: #CCCCCC;\n"
               "     border-width: 1px;\n}\n"
               "</style> </head>")
    html.write("<body>")
    html.write("Report generated: " + time.asctime(time.localtime(time.time())) + "<BR>")
    html.write("<table>")
    comp = prefix.split('/')
    shortprefix = comp.pop()
    wordcloud_path = '~/ResearchTools/IBMWordCloud/'

    topic_ids = range(int(self.config["topics"]))
    for t in topic_ids:
      for a in range(int(self.config["num_entity_types"])):
        topwords = self.type_models[a].TopWords(t)
        topweights = self.type_models[a].TopWeights(t)
        wordle = "\n".join([topwords[i] + "\t" + str(topweights[i] * 100) for i in range(20)])
        f = open ('/tmp/wordle', 'w')
        f.write(wordle)
        f.close()
        print commands.getoutput('java -jar ' + wordcloud_path + 'ibm-word-cloud.jar '
                           + '-c ' + wordcloud_path + 'examples/configuration.txt '
                           + '-w 500 -h 500 --infile /tmp/wordle '
                           + '--outfile ' 
                           + prefix + '.wordcloud.' + str(a) + '.' + str(t) + '.png')
        html.write('<tr><td>' + self.entity_names[a] + ' - topic ' + str(t)
                   + '</td><td><img src = "' 
                   + shortprefix + '.wordcloud.' + str(a) + '.' + str(t) + '.png">'
                   + '</td></tr>')
    
    html.write("</table></body></html>")
    html.close()

  def IndexFile(self, prefix):
    html = open (prefix + '_index.html', 'w')
    html.write ("<html>"
           "<style>"
           "h3 {"
           "  font-family: verdana;"
           "  font-size: 18px;"
           "}"
           "body {"
           "  font-family: verdana;"
           "  font-size: 13px;"
           "}"
           "a {"
           "  font-family: verdana;"
           "  font-size: 13px;"
           "  text-decoration: none;"
           "}"
           "td {"
           "  font-family: verdana;"
           "  font-size: 13px;"
           "  border-style: solid;"
           "  border-color: #CCCCCC;"
           "  border-width: 1px;"
           "}"
           "</style>"
           "</head>"
           "<body>")
    short_prefix = os.path.basename(prefix)
    html.write("<center><h3>" + self.title + "</h3></center><BR>")
    html.write("Report generated: " + time.asctime(time.localtime(time.time())) + "<BR>")
    if os.path.isfile(prefix + '_topics.html'):
      html.write("<A HREF=" + short_prefix + "_topics.html>Topics</a><BR>")
    if os.path.isfile(prefix + '_wordle.html'):
      html.write("<A HREF=" + short_prefix + "_wordle.html>Wordle</a><BR>")
    if os.path.isfile(prefix + '_wordlist.html'):
      html.write("<A HREF=" + short_prefix + "_wordlist.html>Topic assignment of key words</a><BR>")
    if os.path.isfile(prefix + "_all_docs/page_0.html"):
      html.write("<H3>Docs</H3>")
      html.write("<A HREF=" + short_prefix + "_all_docs/page_0.html>All Docs</a><BR>")
    if os.path.isfile(prefix + "_my_docs/page_0.html"):
      html.write("<H3>My Docs</H3>")
      html.write("<A HREF=" + short_prefix + "_my_docs/page_0.html>My Docs</a><BR>")
    for t in range(int(self.config["topics"])):
      if os.path.isfile(prefix + "_topic_" + str(t) + "_docs/page_0.html"):
        html.write("<A HREF=" + short_prefix + "_topic_" + str(t) + "_docs/page_0.html>Topic " + str(t) + "</a><BR>")
    
    html.write("<BR><BR><H3>Run report</h3>")
    html.write("<table>")
    for k in self.config_key_order:
      v = self.config[k]
      html.write("<TR><TD>" + k + "</TD><TD>" + v + "</TD></TR>")
    html.write("</table>")
    html.write("</body></html>")
    html.close()

  def ReadMatrix (self, filename):
    the_matrix = []
    f = open(filename, 'r')
    for line in f:
      line = line.rstrip("\n")
      stringy = line.split()
      the_vector = [float(x) for x in stringy]
      the_matrix.append(the_vector)
    f.close()
    return the_matrix

  def GetSortedDocs(self, id_list, dir):
    f = open(self.docs_file, 'r')
    t = open(self.config["output_prefix"] + ".run.0.train.doc_topic_labels", 'r')

    of = open(dir + 'doc_subset', 'w')

    id = 0
    for line in f:
      line = line.rstrip()
      topic_ids = t.readline()
      topic_ids = topic_ids.rstrip()
      if id in id_list:
        rank = id_list.index(id)
        of.write(str(id) + '' + str(rank) + '' + line + '' + topic_ids + '\n')
      id = id + 1
        
    f.close()
    t.close()
    of.close()
    os.system('sort -k2,2 -n -t"" ' + dir + 'doc_subset > ' + dir + 'sorted_subset')

  def Paint(self, line, word_topics):
    words = line.split('')
    ids = []
    for w in words:
      if w.find('') != -1:
        word, id = w.split('')
        ids.append(id)

    ids.sort(key = lambda x: int(x))
    topics = {}
    topic_ids = word_topics.split()
    if len(ids) != len(topic_ids) - 1:
      print "Whaa paint fail"
    for i in range(len(ids)):
      if not topics.has_key(ids[i]):
        topics[ids[i]] = []
      topics[ids[i]].append(topic_ids[i+1])

    cnt = 0
    for i in range(len(words)):
      if words[i].find('') != -1:
        word, id = words[i].split('')
        topic_id = topics[id].pop()
        words[i] = '<span class="topic' + topic_id + '">' + word + '</span>'
        cnt = cnt + 1
    if cnt != len(topic_ids) - 1:
      print "Whaa paint fail" + str(cnt) + " " + str(len(topic_ids)),"\n"

    return ''.join(words) + '<BR>\n'

  def GetDocString(self, line):
    id, rank, line, word_topics = line.split('')
    if self.docs_mode == 'urlist':
      return '<a href="' + line + '">Doc</a>'
    elif self.docs_mode == 'filelist':
      file = line.rstrip()
      f = open(file, 'r')
      str = f.read()
      f.close()
      return str
    elif self.docs_mode == 'paintlist':
      return self.Paint(line, word_topics)
    else: #default is 'lines'
      return line

  def GenerateDocPages(self, title, id_list, dir, index_href):
    self.GetSortedDocs(id_list, dir)
    f = open(dir + 'sorted_subset', 'r')
    doc_idx = 0

    palette = ["DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "Darkorange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkSlateGrey", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DimGrey", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "Darkorange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkSlateGrey", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DimGrey", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia"]

    for page in range(int(math.ceil(len(id_list) * 1.0 / self.per_page))):
      page_html = open(dir + "page_" + str(page) + ".html", 'w')
      page_html.write('<HTML>\n'
                           '<HEAD>\n'
                           '<style>\n'
                           'a {\n'
                           'font-family: verdana;\n'
                           'font-size: 12px;\n'
                           'text-decoration: none;\n'
                           '}\n'
                           'body {\n'
                           'font-family: verdana;\n'
                           'font-size: 12px;\n'
                           '}\n'
                           'td {\n'
                           'font-family: verdana;\n'
                           'font-size: 12px;\n'
                           'border-width: 1px;\n'
                           'border-color: #CCCCCC;\n'
                           'border-style: solid;\n'
                           '}\n'
                           'p {\n'
                           'font-family: verdana;\n'
                           'font-size: 12px;\n'
                           '}\n')
      for t in range(int(self.config["topics"])):
        page_html.write('.topic' + str(t) + '{\n')
        page_html.write('color: ' + palette[t] + '\n}\n')
      page_html.write('</style>\n'
                      '</HEAD>\n'
                      '<body>')
      page_html.write("Report generated: " + time.asctime(time.localtime(time.time())) + "<BR>")
      page_html.write("<center><h2><a style='font-size:18px' href='" + index_href + "'>" +  self.title + "</a></h2></center><BR>")
      page_html.write('<h3>' + title + ' - Page ' + str(page) + '</h3>')
      for pg in range(int(math.ceil(len(id_list) * 1.0 / self.per_page))):
        if pg != page:
          page_html.write('<a href="page_' + str(pg) + '.html">' + str(pg) + '</a>&nbsp;&nbsp;')
        else:
          page_html.write('<font size=+1>' + str(pg) + '</font>&nbsp;&nbsp;')
      page_html.write('<BR><BR>')
      for idx in range(self.per_page):
        line = f.readline()
        if line == '':
          break

        id, rank, blah, blah2 = line.split('')
        page_html.write("<font face='+1'><b>" + str(doc_idx) + "</b> Doc:" + str(id) + "</font> &nbsp;&nbsp;")

        page_html.write('<table align="left" style="cellpadding:2px"><tr><td>Topic</td>')
        for t in range(int(self.config["topics"])):
          page_html.write('<td class=topic' + str(t)  + '>' + str(t) + '</td>')
        page_html.write('<td>Intercept</td><td>Target</td></tr><tr><td>Probability</td>')
        for t in range(int(self.config["topics"])):
          page_html.write('<td class=topic%d>%.2f</td>' % (t,self.doc_topic_distributions[id_list[doc_idx]][t]))
        page_html.write('<td>-</td><td>-</td></tr>')

        for target in range(int(self.config["num_real_targets"])):
          page_html.write('<tr><td>')
          if len(self.target_names) > 0:
            page_html.write(self.target_names[target] + " Coeffs")
          else:
            page_html.write("Target " + str(target))
          page_html.write('</td>')
          pred = 0
          for t in range(int(self.config["topics"])):
            page_html.write('<td class=topic%d>%.2f</td>' % (t,float(self.coeffs[target][t])))
            pred = pred + float(self.coeffs[target][t]) * self.doc_topic_distributions[id_list[doc_idx]][t]
          page_html.write('<td class=topic%d>%.2f</td>' % (t,float(self.coeffs[target][int(self.config["topics"])])))
          pred = pred - float(self.coeffs[target][int(self.config["topics"])])
          page_html.write('<td>%.2f (%.2f)</td>' % (self.doc_pred_targets[int(id)][target], pred))
          page_html.write('</tr>')
        page_html.write('</table>')

        if int(id) != id_list[doc_idx]:
          print "Dal me kaala he"
        if int(rank) != doc_idx:
          print "Dal me kaala he"

        page_html.write(self.GetDocString(line) + "<BR><BR>")
        doc_idx = doc_idx + 1
        
      page_html.write("</body></html>")
      page_html.close()
    f.close()

  def TopDocs(self, doc_file, doc_mode, per_page, upper_limit, output_prefix, myrange_file=""):
    self.docs_file = doc_file
    self.docs_mode = doc_mode
    self.per_page = per_page

    filename = self.config["output_prefix"] + ".run.0.train.doc_topic_distr"
    self.doc_topic_distributions = self.ReadMatrix(filename)
    if self.config["model_targets"] == "YES":
      filename = self.config["output_prefix"] + ".run.0.train.doc_pred_targets"
      self.doc_pred_targets = self.ReadMatrix(filename)

    if myrange_file != "":
      my_range = []
      mf = open(myrange_file)
      for l in mf:
        my_range.append(int(l.rstrip()))
      mf.close()
      sys.stdout.write("Generating doc distr for my range: " + str(len(my_range)) + " items\n")
      dir = output_prefix + "_my_docs/"
      if not os.path.exists(dir):
        os.makedirs(dir)
      self.GenerateDocPages("My docs", my_range, dir, "../" + os.path.basename(output_prefix) + "_index.html" )
      return
      

    full_range = range(min(upper_limit, len(self.doc_topic_distributions)))
    dir = output_prefix + "_all_docs/"
    if not os.path.exists(dir):
      os.makedirs(dir)
    self.GenerateDocPages("All docs", full_range, dir, "../" + os.path.basename(output_prefix) + "_index.html" )
#      page_html.write("<center><h2><a style='font-size:18px' href='" + index_href + "'>" +  self.title + "</a></h2></center><BR>")
    

    for t in range(int(self.config["topics"])):
      topic_range = range(len(self.doc_topic_distributions))
      topic_range.sort(key=lambda x: self.doc_topic_distributions[x][t], reverse=True)
      if len(topic_range) > upper_limit:
        topic_range = topic_range[0:upper_limit-1]
      dir = output_prefix + "_topic_" + str(t) + "_docs/"
      if not os.path.exists(dir):
        os.makedirs(dir)
      self.GenerateDocPages("Topic " + str(t), topic_range, dir, "../" + os.path.basename(output_prefix) + "_index.html")
    
  def Wordlist(self, wordlist, output_prefix):
    word_topic_distrs = []
    for attr_num in range(int(self.config["num_entity_types"])):
      word_topic_distrs.append(self.ReadMatrix(self.config["output_prefix"]
                                          + ".run.0.model."
                                          + str(attr_num) + ".word_topic_distr"))
    html = open(output_prefix + "_wordlist.html", 'w')
    html.write ("<html>"
           "<head>"
           "<style>"
           "td {"
           "  font-family: verdana;"
           "  font-size: 13px;"
           "  border-style: solid;"
           "  border-color: #CCCCCC;"
           "  border-width: 1px;"
           "}"
           "h2 {"
           "  font-family: verdana;"
           "  font-size: 18px;"
           "}"
           "</style>"
           "</head>"
           "<body>")
    index_href = os.path.basename(output_prefix) + "_index.html"
    html.write("<center><h2><a style='font-size:18px' href='" + index_href + "'>" +  self.title + "</a> - wordlist topic distributions</h2></center><BR>")
    html.write("Report generated: " + time.asctime(time.localtime(time.time())) + "<BR><table border = 0>")

#    sorted_ids = []
#    for t in range(int(self.config["topics"])):
#      ids = range(len(self.type_models[0].topics[t]))
#      ids.sort(key=lambda x: self.type_models[0].topics[t][x], reverse=True)
#      sorted_ids.append(ids)

    f = open(wordlist, 'r')
    for line in f:
#print line
      line = line.rstrip()
      attr, id, topic = line.split(' ')
  
      html.write('<TR><TD>' + self.type_models[int(attr)].dict.id2word[int(id)] + '</TD>')
      #idx = sorted_ids[int(topic)].index(int(id))
#html.write('<TD>' + str(idx) + '</TD>') # rank of word in the topic
      for t in range(int(self.config["topics"])):
        if t == word_topic_distrs[int(attr)][int(id)].index(max(word_topic_distrs[int(attr)][int(id)])):
          html.write('<td style="background-color:#FFCCCC">%.2f</td>' % (word_topic_distrs[int(attr)][int(id)][t]))
        else:
          html.write('<td>%.2f</td>' % (word_topic_distrs[int(attr)][int(id)][t]))
      html.write('</TR>')
    html.write('</table></body></html>')

  def Export(self, prefix, num, no_sort_flag):
#print "Flag is ", no_sort_flag
    html = open (prefix + '_topics.html', 'w')
    html.write ("<html>"
           "<head>"
           "<style>"
           "td {"
           "  font-family: verdana;"
           "  font-size: 13px;"
           "  border-style: solid;"
           "  border-color: #CCCCCC;"
           "  border-width: 1px;"
           "}"
           "body {"
           "  font-family: verdana;"
           "  font-size: 13px;"
           "}"
           "</style>"
           "</head>"
           "<body>")
    html.write("Report generated: " + time.asctime(time.localtime(time.time())) + "<BR><BR>")
    html.write("<table border=0><tr>")

    topic_ids = range(int(self.config["topics"]))
    if no_sort_flag == 0:
      if int(self.config["num_real_targets"]) == 4:
        topic_ids.sort(key=lambda x: abs(float(self.coeffs[0][x]) - float(self.coeffs[2][x])) + abs(float(self.coeffs[1][x]) - float(self.coeffs[3][x])), reverse=True)
      elif int(self.config["num_real_targets"]) == 2:
        topic_ids.sort(key=lambda x: abs(float(self.coeffs[0][x]) - float(self.coeffs[1][x])), reverse=True)
      elif int(self.config["num_real_targets"]) > 0:
        topic_ids.sort(key=lambda x: float(self.coeffs[0][x]), reverse=True)
      sys.stdout.write("Sorting topics")
    else:
      sys.stdout.write("Not sorting topics")
    print len(self.domain_names), " names"

    dom_st_idx = 0
    dom_id = -1
    splits = []
    if int(self.config["md_num_domains"]) > 0:
      splits = self.config["md_splits"].split(',')
    for t in topic_ids:

      if int(self.config["md_num_domains"]) > 0:
        if t == dom_st_idx:
          dom_id += 1
          if dom_id < int(self.config["md_num_domains"]):
            dom_st_idx += int(splits[dom_id])
          if dom_id > 0:
            html.write("</tr><tr>")
          html.write("<td colspan=" + splits[dom_id] + ">")
          html.write("<b><center> Domain:" + self.domain_names[dom_id] + "</center></b>")
          html.write("</td></tr><tr>")
        print "domain is ", dom_id

      html.write("<td valign=top>")
      html.write("<table border=0>")

      html.write("<TR><TD colspan=" + self.config["num_entity_types"] + ">"
             "<b><center>Topic " + str(t) + "</center></b>" 
             "</TD></TR>\n"
             "<TR>")
      for a in range(int(self.config["num_entity_types"])):
        html.write("<TD>")
        html.write("<center><B>" + self.entity_names[a] + "</B></center><BR>")
        html.write("<b>Weight</b>: " + str(round(self.type_models[a].topic_weights[t], 3)) + "<BR><BR>\n")
        for target in range(int(self.config["num_real_targets"])):
          if self.config["model_targets"] == "YES":
            if len(self.target_names):
              html.write("<B>" + self.target_names[target] + " ")
            else:
              html.write("<B>Target " + str(target))
            if int(self.config["num_real_targets"]) == 4 and target % 2 == 1:
              html.write(" coeff-m</b>: " + str(round(float(self.coeffs[target][t]) * 1000, 3)) + "<BR><BR>\n")
            else:
              html.write(" coeff</b>: " + str(round(float(self.coeffs[target][t]), 3)) + "<BR><BR>\n")
        topwords = self.type_models[a].TopWords(t)
        topwords = self.FilterStopWords(topwords, self.stopwords)
        adj_cnt = 0
        adjs = []
        for wordie in topwords:
          if wordie.find('JJ') != -1:
            adjs.append(wordie)
            adj_cnt = adj_cnt + 1
            if adj_cnt >= 20:
              break
        html.write("<BR>\n".join(topwords[0:num]).encode('utf-8'))
#html.write("<BR>\n".join(adjs[0:num]).encode('utf-8'))
        html.write("</TD>")
      html.write("</TR>")
      html.write("</table>")
      html.write("</td>")
    html.write("</tr>\n</table>\n</body>\n</html>")

# if no output_prefix or num_entity_types
# if file no exist report error

# check vocab with topic size
# check number of topics
 
  def ExportLatex(self, prefix, num):
    latex = open (prefix + '_topics.tex', 'w')
    print str(len(self.stopwords)) + " stopwords"
    topic_ids = range(int(self.config["topics"]))
    for t in topic_ids:
      for a in range(int(self.config["num_entity_types"])):
        topwords = self.type_models[a].TopWords(t)
#        print str(len(topwords)) + " words before filtering"
        topwords = self.FilterStopWords(topwords, self.stopwords)
#        print str(len(topwords)) + " words after filtering"
        latex.write("Topic " + str(t) + " & " + self.entity_names[a] + " & " + ", ".join(topwords[0:num]).encode('utf-8'))
        latex.write("\\\\\n")

def MakeDir(output_prefix):
  dir = os.path.dirname(output_prefix)
  if not os.path.exists(dir):
    os.makedirs(dir)

def main():
  opts, args = getopt.getopt(sys.argv[1:], 'x', ['report=', 'entity_names=', 'dict_prefix=', 'output_prefix=', 'wordle', 'topics', 'index', 'topdocs', 'docs_file=', 'docs_mode=', 'limit=', 'title=', 'per_page=', 'wordlist=', 'topicdistr', 'target_names=', 'latex', 'stopwords=', 'avg_node_role_entropy', 'no_sort_topics', 'domain_names=', 'my_docs=', 'docdistr'])

  report = ''
  entity_names = ''
  domain_names = ''
  output_prefix = ''
  dict_prefix = ''
  title = ''
  target_names = ''
  no_sort_topics = 0

  docs_file = ''
  docs_mode = ''
  per_page = 10
  limit    = 100

  wordlist = ''

  stopwordfile = ''

  my_docs = ''

  action_flags = {} 
  for o, v in opts:
    if o == '--report':
      report = v
    elif o == '--entity_names':
      entity_names = v
    elif o == '--dict_prefix':
      dict_prefix = v
    elif o == '--output_prefix':
      output_prefix = v
    elif o == '--docs_file':
      docs_file = v
    elif o == '--docs_mode':
      docs_mode = v
    elif o == '--per_page':
      per_page = int(v)
    elif o == '--limit':
      limit = int(v)
    elif o == '--title':
      title = v
    elif o == '--wordlist':
      wordlist = v
    elif o == '--target_names':
      target_names = v
    elif o == '--domain_names':
      domain_names = v
    elif o == '--stopwords':
      stopwordfile = v
    elif o == '--my_docs':
      my_docs = v
    else:
      action_flags[o] = 1

  print "Report = " + report
  print "Entity names = " + entity_names
  print "Dict prefix = " + dict_prefix 
  print "No sort topics = " , int(action_flags.get('--no_sort_topics', 0))
  no_sort_topics = int(action_flags.get('--no_sort_topics', 0))

  model = Model(report, entity_names, dict_prefix, title, target_names, domain_names)

  MakeDir(output_prefix)

  if stopwordfile != '':
    model.ReadStopWords(stopwordfile)

  if action_flags.get('--wordle', 0) != 0:
    model.Wordle(output_prefix)

  if action_flags.get('--topics', 0) != 0:
    model.Export(output_prefix, 50, no_sort_topics)

  if action_flags.get('--latex', 0) != 0:
    model.ExportLatex(output_prefix, 50)

  if action_flags.get('--topdocs', 0) != 0:
    model.TopDocs(docs_file, docs_mode, per_page, limit, output_prefix)

  if action_flags.get('--docdistr', 0) != 0:
    model.TopDocs(docs_file, docs_mode, per_page, limit, output_prefix, my_docs)

  if action_flags.get('--topicdistr', 0) != 0:
    model.Wordlist(wordlist, output_prefix)

  if action_flags.get('--index', 0) != 0:
    model.IndexFile(output_prefix)

  if action_flags.get('--avg_node_role_entropy', 0) != 0:
    model.NodeRoleEntropy()

if __name__ == "__main__":
  main()
