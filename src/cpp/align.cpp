/*
   align.cpp

Input: Predicted topics for words in vocab - usually generated by link_lda by picking topic with max prob for the word. usually will be [0, nTopics-1]
       True classes for words - external knowledge. this program requires it to be in the range [1, nClasses]

Method: This program tries all alignments of topics to classes and evaluates the predicted class performance of the best match.
        Note that the program requires that the number of classes and topics be the same.

Output: accuracy for best alignment
*/

#include <iostream>
#include <fstream>
#include <vector>
#include <iterator>
#include <iomanip>
#include <algorithm>

using namespace std;

void Read(const string &file, vector<int> &vec, int offset = 0) {
  ifstream ifs(file.c_str());
  while (!ifs.eof()) {
    int tmp;
    ifs >> tmp;
    vec.push_back(tmp);
    vec[vec.size() - 1] += offset;
  } // end while
  vec.pop_back();
}

double Accuracy(vector<int> &pred, vector<int> &orig) {
  int correct = 0;
  int total = 0;
  if (pred.size() != orig.size())
    cerr << "WTF\n";

  for (int i = 0; i < pred.size(); ++i) {
    if (orig[i] == 0)
      continue;
    total++;
    if (pred[i] == orig[i])
      correct++;
  }
  // cout << total << endl;

  return correct * 1.0 / total;
}

void GetPredFromAlign(vector<int> &tm_pred, vector<int> &alignment, vector<int> &pred_class) {
  for (int i = 0; i < tm_pred.size(); ++i) {
    pred_class[i] = alignment[tm_pred[i]]; // translate topic to classes
  }
}

int main(int argc, char **argv) {
  vector<int> tm_pred, true_classes;

  Read(argv[1], tm_pred); 
  Read(argv[2], true_classes);

  vector<int> tmp = true_classes;
  sort(tmp.begin(), tmp.end());
  int n_classes = unique(tmp.begin(), tmp.end()) - tmp.begin();
  if (find(tmp.begin(), tmp.end(), 0) != tmp.end())
    n_classes--;
  // cout << "Num  classes " << n_classes << '\n' << endl;

  vector<int> alignment(n_classes);
  for (int i = 0; i < n_classes; ++i)
    alignment[i] = i + 1;

  vector<int> pred_class(tm_pred.size()), best_perm;
  if (argc >= 4) {
    cout << "User supplied alignment\n";
    vector<int> align;
    Read(argv[3], align);
    copy(align.begin(), align.end(), ostream_iterator<int>(cout, " "));
    GetPredFromAlign(tm_pred, align, pred_class);
    double acc = Accuracy(pred_class, true_classes);
    cout << "Best accuracy " << fixed << setprecision(4) << acc << endl;
    return 0;
  }

  double max_accuracy = -1.0;
  do {
    // copy(alignment.begin(), alignment.end(), ostream_iterator<int>(cout, " "));

    /*for (int i = 0; i < tm_pred.size(); ++i) {
      pred_class[i] = alignment[tm_pred[i]]; // translate topic to classes
      if (tm_pred[i] >= alignment.size())
        cerr << "Weird cluster number\n";
    }*/
    GetPredFromAlign(tm_pred, alignment, pred_class);

    // cout << pred_class.size() << " ---- " << true_classes.size() << endl;
    double acc = Accuracy(pred_class, true_classes);
    if (acc > max_accuracy) {
      max_accuracy = acc;
      best_perm = alignment;
    }
   //  cout << "Accuracy = " <<  acc << endl;
  } while (next_permutation(alignment.begin(), alignment.end()));

  copy(best_perm.begin(), best_perm.end(), ostream_iterator<int>(cout, " "));
  cout << endl;
  cout << "Best accuracy " << fixed << setprecision(4) << max_accuracy << endl;
}
